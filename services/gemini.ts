
import { GoogleGenAI, Type } from "@google/genai";
import { ComicProfile, GeneratedPanelScript, ArtModelType } from "../types";

/**
 * Creates a new instance of GoogleGenAI immediately before making an API call.
 * This ensures the most up-to-date API key from the user selection dialog is utilized.
 */
const getAiClient = () => {
  return new GoogleGenAI({ apiKey: process.env.API_KEY });
};

/**
 * Broadcasts errors to the UI, particularly those related to invalid or missing keys.
 */
const handleApiError = (error: any) => {
  console.error("Gemini API Error:", error);
  window.dispatchEvent(new CustomEvent('gemini-api-error', { 
    detail: { message: error.message || "Unknown API Error" } 
  }));
  throw error;
};

export const generateComicScript = async (
  profile: ComicProfile,
  userPrompt: string,
  isRandom: boolean,
  panelCount: number
): Promise<GeneratedPanelScript[]> => {
  try {
    const ai = getAiClient();
    const characterContext = profile.characters.map(c => `${c.name}: ${c.description}`).join('\n');
    const environmentContext = (profile.environments || []).map(e => `${e.name}: ${e.description}`).join('\n');

    let fullPrompt = `Create a ${panelCount}-panel comic strip script for "${profile.name}".
    Art Style: ${profile.artStyle}
    Environments: ${environmentContext}
    Characters: ${characterContext}
    Task: ${isRandom ? "Random funny situation" : `Plot: ${userPrompt}`}
    Return ONLY JSON.`;

    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: fullPrompt,
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              panelNumber: { type: Type.INTEGER },
              visualDescription: { type: Type.STRING },
              dialogue: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { character: { type: Type.STRING }, text: { type: Type.STRING } } } }
            }
          }
        }
      }
    });

    return JSON.parse(response.text || '[]');
  } catch (error) {
    return handleApiError(error);
  }
};

export const generateComicArt = async (
  profile: ComicProfile,
  script: GeneratedPanelScript[],
  model: ArtModelType
): Promise<string> => {
  try {
    const ai = getAiClient();
    const panelsDesc = script.map(p => `Panel ${p.panelNumber}: ${p.visualDescription}`).join('\n');
    const dialogDesc = script.map(p => `Panel ${p.panelNumber} Dialogue: ${p.dialogue.map(d => `${d.character} says "${d.text}"`).join(', ')}`).join('\n');
    
    let promptText = `Horizontal ${script.length}-panel comic strip. Style: ${profile.artStyle}. Content: ${panelsDesc}. Include legible speech bubbles and dialogue text for characters: ${dialogDesc}. Use the provided character descriptions for visual consistency.`;

    const parts: any[] = [{ text: promptText }];
    profile.characters.forEach(char => {
      if (char.imageUrl?.startsWith('data:')) {
        parts.push({ text: `Visual reference for ${char.name}:` }, { inlineData: { data: char.imageUrl.split(',')[1], mimeType: char.imageUrl.split(';')[0].split(':')[1] } });
      }
    });

    const response = await ai.models.generateContent({
      model: model,
      contents: { parts },
      config: { imageConfig: { aspectRatio: "16:9", imageSize: "1K" } }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
    }
    throw new Error("No image generated by model response");
  } catch (error) {
    return handleApiError(error);
  }
};

export const removeTextFromComic = async (imageBase64: string, model: ArtModelType): Promise<string> => {
  try {
    const ai = getAiClient();
    const prompt = `This is a comic strip. Please edit this image to REMOVE ALL DIALOGUE TEXT from the speech bubbles. The bubbles must remain but they should be completely white and empty inside. Do not change anything else in the image.`;
    
    const response = await ai.models.generateContent({
      model: model,
      contents: { parts: [{ inlineData: { data: imageBase64.split(',')[1], mimeType: 'image/png' } }, { text: prompt }] },
      config: { imageConfig: { aspectRatio: "16:9", imageSize: "1K" } }
    });
    
    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
    }
    throw new Error("Failed clean copy extraction");
  } catch (error) {
    return handleApiError(error);
  }
};

export const generateEnvironmentDescription = async (theme: string): Promise<string> => {
  try {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: `Visual description for: "${theme}".`,
    });
    return response.text || "";
  } catch (error) {
    return handleApiError(error);
  }
};
