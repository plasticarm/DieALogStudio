import { GoogleGenAI, Type } from "@google/genai";
import { ComicProfile, GeneratedPanelScript, ArtModelType } from "../types";

/**
 * Resolves the API key based on the defined priority:
 * 1. User's custom key from profile
 * 2. AI Studio environment check
 * 3. Fallback to process.env.API_KEY
 */
const getApiKey = async (): Promise<string | undefined> => {
  // Check local storage for user custom key
  const savedUser = localStorage.getItem('app_user');
  if (savedUser) {
    const user = JSON.parse(savedUser);
    if (user.apiKeys?.gemini) return user.apiKeys.gemini;
  }

  // Check AI Studio vault
  try {
    const hasStudioKey = await (window as any).aistudio?.hasSelectedApiKey();
    if (hasStudioKey) return process.env.API_KEY; // The platform injects it here
  } catch (e) {}

  // Final fallback
  return process.env.API_KEY;
};

const getAiClient = async () => {
  const apiKey = await getApiKey();
  return new GoogleGenAI({ apiKey: apiKey || '' });
};

const handleApiError = (error: any) => {
  console.error("Gemini API Error:", error);
  window.dispatchEvent(new CustomEvent('gemini-api-error', { 
    detail: { message: error.message || "Unknown API Error" } 
  }));
  throw error;
};

export const generateComicScript = async (
  profile: ComicProfile,
  userPrompt: string,
  isRandom: boolean,
  panelCount: number
): Promise<GeneratedPanelScript[]> => {
  try {
    const ai = await getAiClient();
    const characterContext = profile.characters.map(c => `${c.name}: ${c.description}`).join('\n');
    const environmentContext = (profile.environments || []).map(e => `${e.name}: ${e.description}`).join('\n');

    let fullPrompt = `Create a ${panelCount}-panel comic strip script for "${profile.name}".
    Art Style: ${profile.artStyle}
    Environments: ${environmentContext}
    Characters: ${characterContext}
    Task: ${isRandom ? "Random funny situation" : `Plot: ${userPrompt}`}
    Return ONLY JSON.`;

    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: fullPrompt,
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              panelNumber: { type: Type.INTEGER },
              visualDescription: { type: Type.STRING },
              dialogue: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { character: { type: Type.STRING }, text: { type: Type.STRING } } } }
            }
          }
        }
      }
    });

    return JSON.parse(response.text || '[]');
  } catch (error) {
    return handleApiError(error);
  }
};

export const generateComicArt = async (
  profile: ComicProfile,
  script: GeneratedPanelScript[],
  model: ArtModelType
): Promise<string> => {
  try {
    const ai = await getAiClient();
    const panelsDesc = script.map(p => `Panel ${p.panelNumber}: ${p.visualDescription}`).join('\n');
    const dialogDesc = script.map(p => `Panel ${p.panelNumber} Dialogue: ${p.dialogue.map(d => `${d.character} says "${d.text}"`).join(', ')}`).join('\n');
    
    let promptText = `Horizontal ${script.length}-panel comic strip. Style: ${profile.artStyle}. Content: ${panelsDesc}. Include legible speech bubbles and dialogue text for characters: ${dialogDesc}. Use the provided character descriptions for visual consistency.`;

    const parts: any[] = [{ text: promptText }];
    profile.characters.forEach(char => {
      if (char.imageUrl?.startsWith('data:')) {
        parts.push({ text: `Visual reference for ${char.name}:` }, { inlineData: { data: char.imageUrl.split(',')[1], mimeType: char.imageUrl.split(';')[0].split(':')[1] } });
      }
    });

    const response = await ai.models.generateContent({
      model: model,
      contents: { parts },
      config: { imageConfig: { aspectRatio: "16:9", imageSize: "1K" } }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
    }
    throw new Error("No image generated by model response");
  } catch (error) {
    return handleApiError(error);
  }
};

export const removeTextFromComic = async (imageBase64: string, model: ArtModelType): Promise<string> => {
  try {
    const ai = await getAiClient();
    const prompt = `This is a comic strip. Please edit this image to REMOVE ALL DIALOGUE TEXT from the speech bubbles. The bubbles must remain but they should be completely white and empty inside. Do not change anything else in the image.`;
    
    const response = await ai.models.generateContent({
      model: model,
      contents: { parts: [{ inlineData: { data: imageBase64.split(',')[1], mimeType: 'image/png' } }, { text: prompt }] },
      config: { imageConfig: { aspectRatio: "16:9", imageSize: "1K" } }
    });
    
    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
    }
    throw new Error("Failed clean copy extraction");
  } catch (error) {
    return handleApiError(error);
  }
};

export const generateEnvironmentDescription = async (theme: string): Promise<string> => {
  try {
    const ai = await getAiClient();
    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: `Visual description for: "${theme}".`,
    });
    return response.text || "";
  } catch (error) {
    return handleApiError(error);
  }
};